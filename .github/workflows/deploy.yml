name: Deploy Lambda Stack

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        type: choice
        options:
          - test
          - prod
          - both
          - only-sync-rules

env:
  DEPLOYMENT_BUCKET: kitree-backend
  FIREBASE_PROJECT_ID_TEST: kitree-test
  FIREBASE_PROJECT_ID_PROD: mirai-1111
  FIREBASE_TEST_DIR: firebase-test
  FIREBASE_PROD_DIR: firebase-prod
  LAMBDA_RESOURCE_NAME: JavaFunction

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main repository
        uses: actions/checkout@v3

      - name: Checkout secrets repository
        uses: actions/checkout@v3
        with:
          repository: ${{ github.repository_owner }}/kitree-secrets
          token: ${{ secrets.REPO_ACCESS_TOKEN }}
          path: secrets

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Setup Java
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'
        if: ${{ github.event.inputs.environment != 'only-sync-rules' }}

      - name: Copy secret files
        if: ${{ github.event.inputs.environment != 'only-sync-rules' }}
        run: |
          mkdir -p src/main/resources
          cp secrets/kitree-lambda/secrets.json src/main/resources/
          cp secrets/kitree-lambda/serviceAccountKey.json src/main/resources/
          cp secrets/kitree-lambda/serviceAccountKeyTest.json src/main/resources/

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        if: ${{ github.event.inputs.environment != 'only-sync-rules' }}
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Build and Test
        if: ${{ github.event.inputs.environment != 'only-sync-rules' }}
        run: |
          chmod +x ./gradlew
          ./gradlew clean build test

      - name: Install AWS SAM CLI
        if: ${{ github.event.inputs.environment != 'only-sync-rules' }}
        run: |
          pip install aws-sam-cli

      - name: Deploy Test Environment
        if: ${{ github.event.inputs.environment == 'test' || github.event.inputs.environment == 'both' }}
        run: |
          echo "üöÄ Deploying to TEST environment..."
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT_KEY_TEST }}' > firebase-test-key.json
          export GOOGLE_APPLICATION_CREDENTIALS=firebase-test-key.json
          
          # Verify credentials
          echo "‚úÖ Verifying TEST credentials..."
          if [ -f "firebase-test-key.json" ]; then
            echo "‚úÖ Test service account file created successfully"
          else
            echo "‚ùå Failed to create test service account file"
            exit 1
          fi
          
          sam build
          sam package \
            --template-file .aws-sam/build/template.yaml \
            --output-template-file .aws-sam/build/packaged.yaml \
            --s3-bucket ${{ env.DEPLOYMENT_BUCKET }}
          
          sam deploy \
            --template-file .aws-sam/build/packaged.yaml \
            --stack-name java-lambda-test \
            --capabilities CAPABILITY_IAM \
            --parameter-overrides \
            Environment=test \
            FirebaseProject=${{ env.FIREBASE_PROJECT_ID_TEST }} \
            --no-fail-on-empty-changeset
          
          echo "‚úÖ TEST deployment completed successfully"

      - name: Deploy Production Environment
        if: ${{ github.event.inputs.environment == 'prod' || github.event.inputs.environment == 'both' }}
        run: |
          echo "üöÄ Deploying to PRODUCTION environment..."
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT_KEY_PROD }}' > firebase-prod-key.json
          export GOOGLE_APPLICATION_CREDENTIALS=firebase-prod-key.json
          
          # Verify credentials
          echo "‚úÖ Verifying PRODUCTION credentials..."
          if [ -f "firebase-prod-key.json" ]; then
            echo "‚úÖ Production service account file created successfully"
          else
            echo "‚ùå Failed to create production service account file"
            exit 1
          fi
          
          sam build
          sam package \
            --template-file .aws-sam/build/template.yaml \
            --output-template-file .aws-sam/build/packaged.yaml \
            --s3-bucket ${{ env.DEPLOYMENT_BUCKET }}
          
          sam deploy \
            --template-file .aws-sam/build/packaged.yaml \
            --stack-name java-lambda-prod \
            --capabilities CAPABILITY_IAM \
            --parameter-overrides \
            Environment=prod \
            FirebaseProject=${{ env.FIREBASE_PROJECT_ID_PROD }} \
            --no-fail-on-empty-changeset
          
          echo "‚úÖ PRODUCTION deployment completed successfully"

      - name: Sync Firebase Rules and Indexes
        if: ${{ github.event.inputs.environment == 'prod' || github.event.inputs.environment == 'both' || github.event.inputs.environment == 'only-sync-rules' }}
        run: |
          echo "üîÑ Starting Firebase Rules and Indexes sync..."
          echo "üìã Selected environment: ${{ github.event.inputs.environment }}"
          
          # Install Firebase CLI and Admin SDK
          echo "üì¶ Installing Firebase CLI and Admin SDK..."
          npm install -g firebase-tools
          npm install firebase-admin
          echo "‚úÖ Packages installed successfully"

          # Create service account files
          echo "üîë Creating service account files..."
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT_KEY_TEST }}' > firebase-test-key.json
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT_KEY_PROD }}' > firebase-prod-key.json
          
          # Verify both credential files
          if [ -f "firebase-test-key.json" ]; then
            echo "‚úÖ Test service account file created"
            # Check if file is valid JSON
            if jq empty firebase-test-key.json 2>/dev/null; then
              echo "‚úÖ Test service account JSON is valid"
            else
              echo "‚ùå Test service account JSON is invalid"
              exit 1
            fi
          else
            echo "‚ùå Failed to create test service account file"
            exit 1
          fi
          
          if [ -f "firebase-prod-key.json" ]; then
            echo "‚úÖ Production service account file created"
            # Check if file is valid JSON
            if jq empty firebase-prod-key.json 2>/dev/null; then
              echo "‚úÖ Production service account JSON is valid"
            else
              echo "‚ùå Production service account JSON is invalid"
              exit 1
            fi
          else
            echo "‚ùå Failed to create production service account file"
            exit 1
          fi

          # Create .firebaserc file for project aliases
          echo "‚öôÔ∏è Creating Firebase configuration..."
          cat > .firebaserc << 'EOF'
          {
            "projects": {
              "test": "${{ env.FIREBASE_PROJECT_ID_TEST }}",
              "prod": "${{ env.FIREBASE_PROJECT_ID_PROD }}"
            }
          }
          EOF

          # Create basic firebase.json configuration
          cat > firebase.json << 'EOF'
          {
            "firestore": {
              "rules": "firestore.rules",
              "indexes": "firestore.indexes.json"
            }
          }
          EOF
          echo "‚úÖ Firebase configuration files created"

          # Export from test project
          echo "üì§ Exporting from TEST project (${{ env.FIREBASE_PROJECT_ID_TEST }})..."
          export GOOGLE_APPLICATION_CREDENTIALS=firebase-test-key.json
          
          # Test Firebase CLI authentication
          echo "üîê Testing Firebase CLI authentication with test project..."
          firebase projects:list --json > test_auth_check.json || {
            echo "‚ùå Failed to authenticate with Firebase CLI using test credentials"
            cat test_auth_check.json 2>/dev/null || echo "No output from Firebase CLI"
            exit 1
          }
          echo "‚úÖ Firebase CLI authentication successful"
          
          firebase use test
          echo "‚úÖ Switched to test project"
          
          # Export indexes
          echo "üìã Exporting indexes from test project..."
          firebase firestore:indexes > firestore.indexes.json
          if [ -f "firestore.indexes.json" ]; then
            echo "‚úÖ Indexes exported successfully"
            echo "üìÑ Indexes content preview:"
            head -n 10 firestore.indexes.json
          else
            echo "‚ùå Failed to export indexes"
            exit 1
          fi

          # Export rules using Firebase Admin SDK
          echo "üìã Exporting rules from test project using Admin SDK..."
          cat > export-rules.js << 'EOF'
          const admin = require('firebase-admin');
          const fs = require('fs');

          async function exportRules() {
            try {
              console.log('üîê Initializing Firebase Admin SDK for test project...');
              const serviceAccount = require('./firebase-test-key.json');
              console.log('üìã Service account project_id:', serviceAccount.project_id);
              
              admin.initializeApp({
                credential: admin.credential.cert(serviceAccount),
                projectId: process.env.FIREBASE_PROJECT_ID_TEST
              });
              console.log('‚úÖ Firebase Admin SDK initialized successfully');

              console.log('üìã Getting security rules...');
              const securityRules = admin.securityRules();
              const rulesets = await securityRules.listRulesetMetadata();
              console.log(`üìä Found ${rulesets.length} rulesets`);
              
              if (rulesets.length > 0) {
                console.log('üì§ Getting latest ruleset...');
                const latestRuleset = rulesets[0];
                console.log('üìã Latest ruleset name:', latestRuleset.name);
                const ruleset = await securityRules.getRuleset(latestRuleset.name);
                
                if (ruleset.source && ruleset.source.files) {
                  console.log(`üìÅ Found ${ruleset.source.files.length} files in ruleset`);
                  const rulesFile = ruleset.source.files.find(file => file.name === 'firestore.rules');
                  if (rulesFile && rulesFile.content) {
                    fs.writeFileSync('firestore.rules', rulesFile.content);
                    console.log('‚úÖ Successfully exported rules from test project');
                    console.log('üìÑ Rules preview (first 5 lines):');
                    console.log(rulesFile.content.split('\n').slice(0, 5).join('\n'));
                  } else {
                    console.log('‚ö†Ô∏è No rules content found in test project, creating default rules');
                    fs.writeFileSync('firestore.rules', `rules_version = '2';
          service cloud.firestore {
            match /databases/{database}/documents {
              match /{document=**} {
                allow read, write: if false;
              }
            }
          }`);
                  }
                }
              } else {
                console.log('‚ö†Ô∏è No rulesets found in test project, creating default rules');
                fs.writeFileSync('firestore.rules', `rules_version = '2';
          service cloud.firestore {
            match /databases/{database}/documents {
              match /{document=**} {
                allow read, write: if false;
              }
            }
          }`);
              }
            } catch (error) {
              console.error('‚ùå Error exporting rules:', error.message);
              console.error('üìã Full error:', error);
              // Create a basic rules file as fallback
              fs.writeFileSync('firestore.rules', `rules_version = '2';
          service cloud.firestore {
            match /databases/{database}/documents {
              match /{document=**} {
                allow read, write: if false;
              }
            }
          }`);
              console.log('‚ö†Ô∏è Created fallback rules file');
            }
          }

          exportRules();
          EOF

          export FIREBASE_PROJECT_ID_TEST='${{ env.FIREBASE_PROJECT_ID_TEST }}'
          node export-rules.js

          # Deploy to production project
          echo "üì§ Deploying to PRODUCTION project (${{ env.FIREBASE_PROJECT_ID_PROD }})..."
          export GOOGLE_APPLICATION_CREDENTIALS=firebase-prod-key.json
          
          # Test Firebase CLI authentication for prod
          echo "üîê Testing Firebase CLI authentication with production project..."
          firebase projects:list --json > prod_auth_check.json || {
            echo "‚ùå Failed to authenticate with Firebase CLI using production credentials"
            cat prod_auth_check.json 2>/dev/null || echo "No output from Firebase CLI"
            exit 1
          }
          echo "‚úÖ Firebase CLI authentication successful for production"
          
          firebase use prod
          echo "‚úÖ Switched to production project"

          # Deploy rules to production
          if [ -f "firestore.rules" ]; then
            echo "üìã Deploying rules to production..."
            firebase deploy --only firestore:rules --debug
            if [ $? -eq 0 ]; then
              echo "‚úÖ Rules deployed to production successfully"
            else
              echo "‚ùå Failed to deploy rules to production"
              exit 1
            fi
          else
            echo "‚ö†Ô∏è No rules file found to deploy"
          fi

          # Deploy indexes to production
          if [ -f "firestore.indexes.json" ]; then
            echo "üìã Deploying indexes to production..."
            firebase deploy --only fire
