name: Deploy Lambda Stack

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        type: choice
        options:
          - test
          - prod
          - both
          - only-sync-rules

env:
  DEPLOYMENT_BUCKET: kitree-backend
  FIREBASE_PROJECT_ID_TEST: kitree-test
  FIREBASE_PROJECT_ID_PROD: mirai-1111
  FIREBASE_TEST_DIR: firebase-test
  FIREBASE_PROD_DIR: firebase-prod
  LAMBDA_RESOURCE_NAME: JavaFunction

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main repository
        uses: actions/checkout@v3

      - name: Checkout secrets repository
        uses: actions/checkout@v3
        with:
          repository: ${{ github.repository_owner }}/kitree-secrets
          token: ${{ secrets.REPO_ACCESS_TOKEN }}
          path: secrets

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Setup Java
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'
        if: ${{ github.event.inputs.environment != 'only-sync-rules' }}

      - name: Install Google Cloud SDK
        if: ${{ github.event.inputs.environment == 'prod' || github.event.inputs.environment == 'both' || github.event.inputs.environment == 'only-sync-rules' }}
        run: |
          echo "ğŸ“¦ Installing Google Cloud SDK for debugging..."
          curl https://sdk.cloud.google.com | bash
          source ~/google-cloud-sdk/path.bash.inc
          echo "âœ… Google Cloud SDK installed"

      - name: Copy secret files
        if: ${{ github.event.inputs.environment != 'only-sync-rules' }}
        run: |
          mkdir -p src/main/resources
          cp secrets/kitree-lambda/secrets.json src/main/resources/
          cp secrets/kitree-lambda/serviceAccountKey.json src/main/resources/
          cp secrets/kitree-lambda/serviceAccountKeyTest.json src/main/resources/

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        if: ${{ github.event.inputs.environment != 'only-sync-rules' }}
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Build and Test
        if: ${{ github.event.inputs.environment != 'only-sync-rules' }}
        run: |
          chmod +x ./gradlew
          ./gradlew clean build test

      - name: Install AWS SAM CLI
        if: ${{ github.event.inputs.environment != 'only-sync-rules' }}
        run: |
          pip install aws-sam-cli

      - name: Deploy Test Environment
        if: ${{ github.event.inputs.environment == 'test' || github.event.inputs.environment == 'both' }}
        run: |
          echo "ğŸš€ Deploying to TEST environment..."
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT_KEY_TEST }}' > firebase-test-key.json
          export GOOGLE_APPLICATION_CREDENTIALS=firebase-test-key.json
          
          echo "âœ… Verifying TEST credentials..."
          if [ -f "firebase-test-key.json" ]; then
            echo "âœ… Test service account file created successfully"
            echo "ğŸ“§ Test service account email: $(cat firebase-test-key.json | jq -r '.client_email')"
            echo "ğŸ“‹ Test project ID: $(cat firebase-test-key.json | jq -r '.project_id')"
          else
            echo "âŒ Failed to create test service account file"
            exit 1
          fi
          
          sam build
          sam package \
            --template-file .aws-sam/build/template.yaml \
            --output-template-file .aws-sam/build/packaged.yaml \
            --s3-bucket ${{ env.DEPLOYMENT_BUCKET }}
          
          sam deploy \
            --template-file .aws-sam/build/packaged.yaml \
            --stack-name java-lambda-test \
            --capabilities CAPABILITY_IAM \
            --parameter-overrides \
            Environment=test \
            FirebaseProject=${{ env.FIREBASE_PROJECT_ID_TEST }} \
            --no-fail-on-empty-changeset
          
          echo "âœ… TEST deployment completed successfully"

      - name: Deploy Production Environment
        if: ${{ github.event.inputs.environment == 'prod' || github.event.inputs.environment == 'both' }}
        run: |
          echo "ğŸš€ Deploying to PRODUCTION environment..."
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT_KEY_PROD }}' > firebase-prod-key.json
          export GOOGLE_APPLICATION_CREDENTIALS=firebase-prod-key.json
          
          echo "âœ… Verifying PRODUCTION credentials..."
          if [ -f "firebase-prod-key.json" ]; then
            echo "âœ… Production service account file created successfully"
            echo "ğŸ“§ Production service account email: $(cat firebase-prod-key.json | jq -r '.client_email')"
            echo "ğŸ“‹ Production project ID: $(cat firebase-prod-key.json | jq -r '.project_id')"
          else
            echo "âŒ Failed to create production service account file"
            exit 1
          fi
          
          sam build
          sam package \
            --template-file .aws-sam/build/template.yaml \
            --output-template-file .aws-sam/build/packaged.yaml \
            --s3-bucket ${{ env.DEPLOYMENT_BUCKET }}
          
          sam deploy \
            --template-file .aws-sam/build/packaged.yaml \
            --stack-name java-lambda-prod \
            --capabilities CAPABILITY_IAM \
            --parameter-overrides \
            Environment=prod \
            FirebaseProject=${{ env.FIREBASE_PROJECT_ID_PROD }} \
            --no-fail-on-empty-changeset
          
          echo "âœ… PRODUCTION deployment completed successfully"

      - name: Sync Firebase Rules and Indexes
        if: ${{ github.event.inputs.environment == 'prod' || github.event.inputs.environment == 'both' || github.event.inputs.environment == 'only-sync-rules' }}
        run: |
          echo "ğŸ”„ Starting Firebase Rules and Indexes sync..."
          echo "ğŸ“‹ Selected environment: ${{ github.event.inputs.environment }}"
          
          # Install Firebase CLI and Admin SDK
          echo "ğŸ“¦ Installing Firebase CLI and Admin SDK..."
          npm install -g firebase-tools
          npm install firebase-admin
          echo "âœ… Packages installed successfully"

          # Create service account files
          echo "ğŸ”‘ Creating service account files..."
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT_KEY_TEST }}' > firebase-test-key.json
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT_KEY_PROD }}' > firebase-prod-key.json
          
          # Verify both credential files
          echo "ğŸ” Verifying credential files..."
          if [ -f "firebase-test-key.json" ]; then
            echo "âœ… Test service account file created"
            echo "ğŸ“§ Test service account email: $(cat firebase-test-key.json | jq -r '.client_email')"
            echo "ğŸ“‹ Test project ID from key: $(cat firebase-test-key.json | jq -r '.project_id')"
            echo "ğŸ“‹ Expected test project ID: ${{ env.FIREBASE_PROJECT_ID_TEST }}"
          
            if jq empty firebase-test-key.json 2>/dev/null; then
              echo "âœ… Test service account JSON is valid"
            else
              echo "âŒ Test service account JSON is invalid"
              exit 1
            fi
          else
            echo "âŒ Failed to create test service account file"
            exit 1
          fi
          
          if [ -f "firebase-prod-key.json" ]; then
            echo "âœ… Production service account file created"
            echo "ğŸ“§ Production service account email: $(cat firebase-prod-key.json | jq -r '.client_email')"
            echo "ğŸ“‹ Production project ID from key: $(cat firebase-prod-key.json | jq -r '.project_id')"
            echo "ğŸ“‹ Expected production project ID: ${{ env.FIREBASE_PROJECT_ID_PROD }}"
          
            if jq empty firebase-prod-key.json 2>/dev/null; then
              echo "âœ… Production service account JSON is valid"
            else
              echo "âŒ Production service account JSON is invalid"
              exit 1
            fi
          else
            echo "âŒ Failed to create production service account file"
            exit 1
          fi

          # Debug service account identity and permissions
          echo "ğŸ” Debugging production service account identity..."
          source ~/google-cloud-sdk/path.bash.inc
          export GOOGLE_APPLICATION_CREDENTIALS=firebase-prod-key.json
          gcloud auth activate-service-account --key-file=firebase-prod-key.json
          gcloud config set project ${{ env.FIREBASE_PROJECT_ID_PROD }}
          
          echo "ğŸ‘¤ Currently active account:"
          gcloud auth list --filter=status:ACTIVE --format="value(account)"
          
          echo "ğŸ” Checking IAM permissions for production service account..."
          PROD_EMAIL=$(cat firebase-prod-key.json | jq -r '.client_email')
          echo "ğŸ“§ Checking permissions for: $PROD_EMAIL"
          
          echo "ğŸ·ï¸ All IAM roles for this service account:"
          gcloud projects get-iam-policy ${{ env.FIREBASE_PROJECT_ID_PROD }} \
            --flatten="bindings[].members" \
            --format="table(bindings.role)" \
            --filter="bindings.members:$PROD_EMAIL" || echo "âš ï¸ Could not retrieve IAM policy"
          
          echo "ğŸ§ª Testing Firebase API access..."
          gcloud auth print-access-token > /dev/null
          if [ $? -eq 0 ]; then
            echo "âœ… Can generate access token"
          else
            echo "âŒ Cannot generate access token"
          fi

          # Create .firebaserc file for project aliases
          echo "âš™ï¸ Creating Firebase configuration..."
          cat > .firebaserc << 'EOF'
          {
            "projects": {
              "test": "${{ env.FIREBASE_PROJECT_ID_TEST }}",
              "prod": "${{ env.FIREBASE_PROJECT_ID_PROD }}"
            }
          }
          EOF

          # Create basic firebase.json configuration
          cat > firebase.json << 'EOF'
          {
            "firestore": {
              "rules": "firestore.rules",
              "indexes": "firestore.indexes.json"
            }
          }
          EOF
          echo "âœ… Firebase configuration files created"

          # Export from test project
          echo "ğŸ“¤ Exporting from TEST project (${{ env.FIREBASE_PROJECT_ID_TEST }})..."
          export GOOGLE_APPLICATION_CREDENTIALS=firebase-test-key.json
          
          # Test Firebase CLI authentication
          echo "ğŸ” Testing Firebase CLI authentication with test project..."
          firebase projects:list --json > test_auth_check.json || {
            echo "âŒ Failed to authenticate with Firebase CLI using test credentials"
            cat test_auth_check.json 2>/dev/null || echo "No output from Firebase CLI"
            exit 1
          }
          echo "âœ… Firebase CLI authentication successful for test project"
          
          firebase use test
          echo "âœ… Switched to test project"
          
          # Export indexes
          echo "ğŸ“‹ Exporting indexes from test project..."
          firebase firestore:indexes > firestore.indexes.json
          if [ -f "firestore.indexes.json" ]; then
            echo "âœ… Indexes exported successfully"
            echo "ğŸ“„ Indexes file size: $(wc -l < firestore.indexes.json) lines"
            echo "ğŸ“„ Indexes content preview:"
            head -n 10 firestore.indexes.json
          else
            echo "âŒ Failed to export indexes"
            exit 1
          fi

          # Export rules using Firebase Admin SDK
          echo "ğŸ“‹ Exporting rules from test project using Admin SDK..."
          cat > export-rules.js << 'EOF'
          const admin = require('firebase-admin');
          const fs = require('fs');

          async function exportRules() {
            try {
              console.log('ğŸ” Initializing Firebase Admin SDK for test project...');
              const serviceAccount = require('./firebase-test-key.json');
              console.log('ğŸ“§ Service account email:', serviceAccount.client_email);
              console.log('ğŸ“‹ Service account project_id:', serviceAccount.project_id);
          
              admin.initializeApp({
                credential: admin.credential.cert(serviceAccount),
                projectId: process.env.FIREBASE_PROJECT_ID_TEST
              });
              console.log('âœ… Firebase Admin SDK initialized successfully');

              console.log('ğŸ“‹ Getting security rules...');
              const securityRules = admin.securityRules();
              const rulesets = await securityRules.listRulesetMetadata();
              console.log(`ğŸ“Š Found ${rulesets ? rulesets.length : 0} rulesets`);
          
              if (rulesets && rulesets.length > 0) {
                console.log('ğŸ“¤ Getting latest ruleset...');
                const latestRuleset = rulesets[0];
                console.log('ğŸ“‹ Latest ruleset name:', latestRuleset.name);
                const ruleset = await securityRules.getRuleset(latestRuleset.name);
          
                if (ruleset.source && ruleset.source.files) {
                  console.log(`ğŸ“ Found ${ruleset.source.files.length} files in ruleset`);
                  const rulesFile = ruleset.source.files.find(file => file.name === 'firestore.rules');
                  if (rulesFile && rulesFile.content) {
                    fs.writeFileSync('firestore.rules', rulesFile.content);
                    console.log('âœ… Successfully exported rules from test project');
                    console.log('ğŸ“„ Rules file size:', rulesFile.content.length, 'characters');
                    console.log('ğŸ“„ Rules preview (first 5 lines):');
                    console.log(rulesFile.content.split('\n').slice(0, 5).join('\n'));
                  } else {
                    console.log('âš ï¸ No rules content found in test project, creating default rules');
                    fs.writeFileSync('firestore.rules', `rules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if false;\n    }\n  }\n}`);
                  }
                }
              } else {
                console.log('âš ï¸ No rulesets found in test project, creating default rules');
                fs.writeFileSync('firestore.rules', `rules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if false;\n    }\n  }\n}`);
              }
            } catch (error) {
              console.error('âŒ Error exporting rules:', error.message);
              console.error('ğŸ“‹ Error code:', error.code);
              console.error('ğŸ“‹ Full error:', error);
              // Create a basic rules file as fallback
              fs.writeFileSync('firestore.rules', `rules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if false;\n    }\n  }\n}`);
              console.log('âš ï¸ Created fallback rules file');
            }
          }

          exportRules();
          EOF

          export FIREBASE_PROJECT_ID_TEST='${{ env.FIREBASE_PROJECT_ID_TEST }}'
          node export-rules.js

          # Deploy to production project
          echo "ğŸ“¤ Deploying to PRODUCTION project (${{ env.FIREBASE_PROJECT_ID_PROD }})..."
          export GOOGLE_APPLICATION_CREDENTIALS=firebase-prod-key.json
          
          # Test Firebase CLI authentication for prod
          echo "ğŸ” Testing Firebase CLI authentication with production project..."
          firebase projects:list --json > prod_auth_check.json || {
            echo "âŒ Failed to authenticate with Firebase CLI using production credentials"
            cat prod_auth_check.json 2>/dev/null || echo "No output from Firebase CLI"
            exit 1
          }
          echo "âœ… Firebase CLI authentication successful for production"
          
          firebase use prod
          echo "âœ… Switched to production project"

          # Deploy rules to production
          if [ -f "firestore.rules" ]; then
            echo "ğŸ“‹ Deploying rules to production..."
            echo "ğŸ“„ Rules file content preview:"
            head -n 5 firestore.rules
            echo "ğŸš€ Starting Firebase rules deployment with enhanced debugging..."
            firebase deploy --only firestore:rules --debug --force
            if [ $? -eq 0 ]; then
              echo "âœ… Rules deployed to production successfully"
            else
              echo "âŒ Failed to deploy rules to production"
              echo "ğŸ” Checking Firebase project configuration..."
              firebase projects:list
              echo "ğŸ” Current project settings:"
              firebase use
              echo "âš ï¸  Please add the following roles to service account $PROD_EMAIL:"
              echo "   - Firebase Admin"
              echo "   - Cloud Datastore Index Admin" 
              echo "   - Firebase Rules Admin"
              exit 1
            fi
          else
            echo "âš ï¸ No rules file found to deploy"
          fi

          # Deploy indexes to production
          if [ -f "firestore.indexes.json" ]; then
            echo "ğŸ“‹ Deploying indexes to production..."
            echo "ğŸ“„ Indexes file content preview:"
            head -n 5 firestore.indexes.json
            echo "ğŸš€ Starting Firebase indexes deployment with enhanced debugging..."
            firebase deploy --only firestore:indexes --debug --force
            if [ $? -eq 0 ]; then
              echo "âœ… Indexes deployed to production successfully"
            else
              echo "âŒ Failed to deploy indexes to production"
              echo "âš ï¸  Please add the following roles to service account $PROD_EMAIL:"
              echo "   - Firebase Admin"
              echo "   - Cloud Datastore Index Admin" 
              echo "   - Firebase Rules Admin"
              exit 1
            fi
          else
            echo "âš ï¸ No indexes file found to deploy"
          fi

          # Cleanup
          echo "ğŸ§¹ Cleaning up temporary files..."
          rm -f firebase-test-key.json firebase-prod-key.json firestore.rules firestore.indexes.json export-rules.js .firebaserc firebase.json test_auth_check.json prod_auth_check.json
          echo "âœ… Successfully completed Firebase rules and indexes sync"

      - name: Cleanup S3 Artifacts
        if: always() && github.event.inputs.environment != 'only-sync-rules'
        run: |
          if [ -f ".aws-sam/build/packaged.yaml" ]; then
            S3_URI=$(grep -A 1 "CodeUri:" .aws-sam/build/packaged.yaml | grep "s3://" | tr -d ' ')
            if [ ! -z "$S3_URI" ]; then
              echo "ğŸ§¹ Cleaning up S3 artifact: $S3_URI"
              aws s3 rm "$S3_URI" || echo "âŒ Failed to delete S3 artifact"
            fi
          fi
