name: Deploy Lambda Stack

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        type: choice
        options:
          - test
          - prod
          - both
          - only-sync-rules

permissions:
  contents: read
  id-token: write

env:
  DEPLOYMENT_BUCKET: kitree-backend
  FIREBASE_PROJECT_ID_TEST: kitree-test
  FIREBASE_PROJECT_ID_PROD: mirai-1111
  FIREBASE_TEST_DIR: firebase-test
  FIREBASE_PROD_DIR: firebase-prod
  LAMBDA_RESOURCE_NAME: JavaFunction
  API_DOMAIN_TEST: api-test.kitree.co.in
  API_DOMAIN_PROD: api.kitree.co.in
  API_CERTIFICATE_ARN: arn:aws:acm:ap-south-1:585768141144:certificate/538dd249-d0e5-4b9d-b06a-8063f3532846

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main repository
        uses: actions/checkout@v4

      - name: Checkout secrets repository
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/kitree-secrets
          token: ${{ secrets.REPO_ACCESS_TOKEN }}
          path: secrets

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
        if: ${{ github.event.inputs.environment != 'only-sync-rules' }}

      # (Optional) You probably do not need gcloud for Firebase CLI,
      # so consider deleting this step entirely.
      - name: Install Google Cloud SDK
        if: ${{ github.event.inputs.environment == 'prod' || github.event.inputs.environment == 'both' || github.event.inputs.environment == 'only-sync-rules' }}
        run: |
          echo "üì¶ Installing Google Cloud SDK for debugging..."
          curl https://sdk.cloud.google.com | bash
          source ~/google-cloud-sdk/path.bash.inc
          echo "‚úÖ Google Cloud SDK installed"

      - name: Copy secret files
        if: ${{ github.event.inputs.environment != 'only-sync-rules' }}
        run: |
          mkdir -p src/main/resources
          cp secrets/kitree-lambda/secrets.json src/main/resources/
          cp secrets/kitree-lambda/serviceAccountKey.json src/main/resources/
          cp secrets/kitree-lambda/serviceAccountKeyTest.json src/main/resources/

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        if: ${{ github.event.inputs.environment != 'only-sync-rules' }}
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          # Best practice: migrate to role-to-assume + OIDC when you‚Äôre ready.
          # role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          # (see AWS/GitHub docs on OIDC)
          # [web:56][web:57][web:58]

      - name: Install AWS SAM CLI
        if: ${{ github.event.inputs.environment != 'only-sync-rules' }}
        run: |
          pip install aws-sam-cli

      - name: Deploy Test Environment
        if: ${{ github.event.inputs.environment == 'test' || github.event.inputs.environment == 'both' }}
        run: |
          echo "üöÄ Deploying to TEST environment..."
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT_KEY_TEST }}' > firebase-test-key.json
          export GOOGLE_APPLICATION_CREDENTIALS=firebase-test-key.json
          
          echo "‚úÖ Verifying TEST credentials..."
          if [ -f "firebase-test-key.json" ]; then
            echo "‚úÖ Test service account file created successfully"
            echo "üìß Test service account email: $(cat firebase-test-key.json | jq -r '.client_email')"
            echo "üìã Test project ID: $(cat firebase-test-key.json | jq -r '.project_id')"
          else
            echo "‚ùå Failed to create test service account file"
            exit 1
          fi
          
          sam build
          sam package \
            --template-file .aws-sam/build/template.yaml \
            --output-template-file .aws-sam/build/packaged.yaml \
            --s3-bucket ${{ env.DEPLOYMENT_BUCKET }}

          sam deploy \
            --template-file .aws-sam/build/packaged.yaml \
            --stack-name java-lambda-test \
            --capabilities CAPABILITY_IAM \
            --parameter-overrides \
              Environment=test \
              FirebaseProject=${{ env.FIREBASE_PROJECT_ID_TEST }} \
              ApiDomainName=${{ env.API_DOMAIN_TEST }} \
              CertificateArn=${{ env.API_CERTIFICATE_ARN }} \
            --no-fail-on-empty-changeset

      - name: Deploy Production Environment
        if: ${{ github.event.inputs.environment == 'prod' || github.event.inputs.environment == 'both' }}
        run: |
          echo "üöÄ Deploying to PRODUCTION environment..."
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT_KEY_PROD }}' > firebase-prod-key.json
          export GOOGLE_APPLICATION_CREDENTIALS=firebase-prod-key.json
          
          echo "‚úÖ Verifying PRODUCTION credentials..."
          if [ -f "firebase-prod-key.json" ]; then
            echo "‚úÖ Production service account file created successfully"
            echo "üìß Production service account email: $(cat firebase-prod-key.json | jq -r '.client_email')"
            echo "üìã Production project ID: $(cat firebase-prod-key.json | jq -r '.project_id')"
          else
            echo "‚ùå Failed to create production service account file"
            exit 1
          fi
          
          sam build
          sam package \
            --template-file .aws-sam/build/template.yaml \
            --output-template-file .aws-sam/build/packaged.yaml \
            --s3-bucket ${{ env.DEPLOYMENT_BUCKET }}

          sam deploy \
            --template-file .aws-sam/build/packaged.yaml \
            --stack-name java-lambda-prod \
            --capabilities CAPABILITY_IAM \
            --parameter-overrides \
              Environment=prod \
              FirebaseProject=${{ env.FIREBASE_PROJECT_ID_PROD }} \
              ApiDomainName=${{ env.API_DOMAIN_PROD }} \
              CertificateArn=${{ env.API_CERTIFICATE_ARN }} \
            --no-fail-on-empty-changeset

      - name: Sync Firebase Rules and Indexes
        if: ${{ github.event.inputs.environment == 'prod' || github.event.inputs.environment == 'both' || github.event.inputs.environment == 'only-sync-rules' }}
        run: |
          echo "üîÑ Starting Firebase Rules and Indexes sync..."
          echo "üìã Selected environment: ${{ github.event.inputs.environment }}"
          
          # Install Firebase CLI and Admin SDK
          echo "üì¶ Installing Firebase CLI and Admin SDK..."
          npm install -g firebase-tools
          npm install firebase-admin
          echo "‚úÖ Packages installed successfully"

          # Create service account files
          echo "üîë Creating service account files..."
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT_KEY_TEST }}' > firebase-test-key.json
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT_KEY_PROD }}' > firebase-prod-key.json
          
          # Verify both credential files
          echo "üîç Verifying credential files..."
          if [ -f "firebase-test-key.json" ]; then
            echo "‚úÖ Test service account file created"
            echo "üìß Test service account email: $(cat firebase-test-key.json | jq -r '.client_email')"
            echo "üìã Test project ID from key: $(cat firebase-test-key.json | jq -r '.project_id')"
            echo "üìã Expected test project ID: ${{ env.FIREBASE_PROJECT_ID_TEST }}"
          
            if jq empty firebase-test-key.json 2>/dev/null; then
              echo "‚úÖ Test service account JSON is valid"
            else
              echo "‚ùå Test service account JSON is invalid"
              exit 1
            fi
          else
            echo "‚ùå Failed to create test service account file"
            exit 1
          fi
          
          if [ -f "firebase-prod-key.json" ]; then
            echo "‚úÖ Production service account file created"
            echo "üìß Production service account email: $(cat firebase-prod-key.json | jq -r '.client_email')"
            echo "üìã Production project ID from key: $(cat firebase-prod-key.json | jq -r '.project_id')"
            echo "üìã Expected production project ID: ${{ env.FIREBASE_PROJECT_ID_PROD }}"
          
            if jq empty firebase-prod-key.json 2>/dev/null; then
              echo "‚úÖ Production service account JSON is valid"
            else
              echo "‚ùå Production service account JSON is invalid"
              exit 1
            fi
          else
            echo "‚ùå Failed to create production service account file"
            exit 1
          fi

          # Create .firebaserc file for project aliases
          echo "‚öôÔ∏è Creating Firebase configuration..."
          cat > .firebaserc << 'EOF'
          {
            "projects": {
              "test": "${{ env.FIREBASE_PROJECT_ID_TEST }}",
              "prod": "${{ env.FIREBASE_PROJECT_ID_PROD }}"
            }
          }
          EOF

          # Create basic firebase.json configuration
          cat > firebase.json << 'EOF'
          {
            "firestore": {
              "rules": "firestore.rules",
              "indexes": "firestore.indexes.json"
            }
          }
          EOF
          echo "‚úÖ Firebase configuration files created"

          # Export from test project
          echo "üì§ Exporting from TEST project (${{ env.FIREBASE_PROJECT_ID_TEST }})..."
          export GOOGLE_APPLICATION_CREDENTIALS=firebase-test-key.json
          
          # Test Firebase CLI authentication
          echo "üîê Testing Firebase CLI authentication with test project..."
          firebase projects:list --json > test_auth_check.json || {
            echo "‚ùå Failed to authenticate with Firebase CLI using test credentials"
            cat test_auth_check.json 2>/dev/null || echo "No output from Firebase CLI"
            exit 1
          }
          echo "‚úÖ Firebase CLI authentication successful for test project"
          
          firebase use test
          echo "‚úÖ Switched to test project"
          
          # Export indexes
          echo "üìã Exporting indexes from test project..."
          firebase firestore:indexes > firestore.indexes.json
          if [ -f "firestore.indexes.json" ]; then
            echo "‚úÖ Indexes exported successfully"
            echo "üìÑ Indexes file size: $(wc -l < firestore.indexes.json) lines"
            echo "üìÑ Indexes content preview:"
            head -n 10 firestore.indexes.json
          else
            echo "‚ùå Failed to export indexes"
            exit 1
          fi

          # Export rules using Firebase Admin SDK with CORRECTED logic
          echo "üìã Exporting rules from test project using Admin SDK..."
          cat > export-rules.js << 'EOF'
          const admin = require('firebase-admin');
          const fs = require('fs');

          async function exportRules() {
            try {
              console.log('üîê Initializing Firebase Admin SDK for test project...');
              const serviceAccount = require('./firebase-test-key.json');
              console.log('üìß Service account email:', serviceAccount.client_email);
              console.log('üìã Service account project_id:', serviceAccount.project_id);
              console.log('üìã Environment FIREBASE_PROJECT_ID_TEST:', process.env.FIREBASE_PROJECT_ID_TEST);
          
              admin.initializeApp({
                credential: admin.credential.cert(serviceAccount),
                projectId: process.env.FIREBASE_PROJECT_ID_TEST
              });
              console.log('‚úÖ Firebase Admin SDK initialized successfully');

              console.log('üìã Getting security rules...');
              const securityRules = admin.securityRules();
          
              console.log('üîç Attempting to list all rulesets...');
              const rulesetsResponse = await securityRules.listRulesetMetadata();
              console.log('üìä Raw rulesets response type:', typeof rulesetsResponse);
          
              // FIXED: Access the rulesets array from the response object
              const rulesets = rulesetsResponse.rulesets || rulesetsResponse;
              console.log(`üìä Found ${rulesets ? rulesets.length : 0} rulesets`);
          
              if (rulesets && Array.isArray(rulesets) && rulesets.length > 0) {
                console.log('üì§ Getting latest ruleset...');
                const latestRuleset = rulesets[0];
                console.log('üìã Latest ruleset details:', JSON.stringify(latestRuleset, null, 2));
          
                const ruleset = await securityRules.getRuleset(latestRuleset.name);
                console.log('üìã Retrieved ruleset has source:', !!ruleset.source);
                console.log('üìã Source type:', typeof ruleset.source);
                console.log('üìã Source is array:', Array.isArray(ruleset.source));
          
                // CORRECTED: ruleset.source is directly the array of files
                if (ruleset.source && Array.isArray(ruleset.source)) {
                  console.log(`üìÅ Found ${ruleset.source.length} files in ruleset`);
                  console.log('üìÅ Files in ruleset:', ruleset.source.map(f => f.name));
          
                  const rulesFile = ruleset.source.find(file => file.name === 'firestore.rules');
                  if (rulesFile && rulesFile.content) {
                    fs.writeFileSync('firestore.rules', rulesFile.content);
                    console.log('‚úÖ Successfully exported rules from test project');
                    console.log('üìÑ Rules file size:', rulesFile.content.length, 'characters');
                    console.log('üìÑ Rules preview (first 10 lines):');
                    console.log(rulesFile.content.split('\n').slice(0, 10).join('\n'));
                    console.log('üìÑ Rules preview (last 5 lines):');
                    console.log(rulesFile.content.split('\n').slice(-5).join('\n'));
                  } else {
                    console.log('‚ö†Ô∏è No rules content found in ruleset file');
                    console.log('üìã Rules file details:', rulesFile);
                    throw new Error('No rules content in file');
                  }
                } else {
                  console.log('‚ö†Ô∏è Source is not an array');
                  console.log('üìã Ruleset source structure:', ruleset.source);
                  throw new Error('Unexpected source structure');
                }
              } else {
                console.log('‚ö†Ô∏è No rulesets found or rulesets is not an array');
                if (rulesetsResponse) {
                  console.log('üìã Full response structure:', Object.keys(rulesetsResponse));
                }
                throw new Error('No rulesets found');
              }
            } catch (error) {
              console.error('‚ùå Error in exportRules:', error.message);
              console.error('üìã Error code:', error.code);
              console.error('üìã Full error:', error);
          
              // Create a basic rules file as fallback
              console.log('‚ö†Ô∏è Creating fallback rules file due to error');
              fs.writeFileSync('firestore.rules', `rules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if false;\n    }\n  }\n}`);
              console.log('üìÑ Fallback rules created');
          
              // Re-throw the error so we know something went wrong
              throw error;
            }
          }

          exportRules().catch(error => {
            console.error('üí• Final error in exportRules:', error);
            process.exit(1);
          });
          EOF

          export FIREBASE_PROJECT_ID_TEST='${{ env.FIREBASE_PROJECT_ID_TEST }}'
          node export-rules.js

          # Verify the exported rules
          if [ -f "firestore.rules" ]; then
            echo "üìÑ Final exported rules file content:"
            cat firestore.rules
            echo ""
            echo "üìä Rules file stats:"
            echo "  - Size: $(wc -c < firestore.rules) bytes"
            echo "  - Lines: $(wc -l < firestore.rules) lines"
            echo "  - Words: $(wc -w < firestore.rules) words"
          else
            echo "‚ùå No rules file was created!"
            exit 1
          fi

          # Deploy to production project
          echo "üì§ Deploying to PRODUCTION project (${{ env.FIREBASE_PROJECT_ID_PROD }})..."
          export GOOGLE_APPLICATION_CREDENTIALS=firebase-prod-key.json
          
          # Test Firebase CLI authentication for prod
          echo "üîê Testing Firebase CLI authentication with production project..."
          firebase projects:list --json > prod_auth_check.json || {
            echo "‚ùå Failed to authenticate with Firebase CLI using production credentials"
            cat prod_auth_check.json 2>/dev/null || echo "No output from Firebase CLI"
            exit 1
          }
          echo "‚úÖ Firebase CLI authentication successful for production"
          
          firebase use prod
          echo "‚úÖ Switched to production project"

          # Deploy rules to production with force flag to avoid confirmations
          if [ -f "firestore.rules" ]; then
            echo "üìã Deploying rules to production..."
            echo "üìÑ Rules file content preview:"
            head -n 5 firestore.rules
            echo "üöÄ Starting Firebase rules deployment (force mode to avoid confirmations)..."
            firebase deploy --only firestore:rules --force --non-interactive
            if [ $? -eq 0 ]; then
              echo "‚úÖ Rules deployed to production successfully"
            else
              echo "‚ùå Failed to deploy rules to production"
              exit 1
            fi
          else
            echo "‚ö†Ô∏è No rules file found to deploy"
          fi

          # Deploy indexes to production with force flag to avoid confirmations
          if [ -f "firestore.indexes.json" ]; then
            echo "üìã Deploying indexes to production..."
            echo "üìÑ Indexes file content preview:"
            head -n 5 firestore.indexes.json
            echo "üöÄ Starting Firebase indexes deployment (force mode to avoid confirmations)..."
            firebase deploy --only firestore:indexes --force --non-interactive
            if [ $? -eq 0 ]; then
              echo "‚úÖ Indexes deployed to production successfully"
            else
              echo "‚ùå Failed to deploy indexes to production"
              exit 1
            fi
          else
            echo "‚ö†Ô∏è No indexes file found to deploy"
          fi

          # Cleanup
          echo "üßπ Cleaning up temporary files..."
          rm -f firebase-test-key.json firebase-prod-key.json firestore.rules firestore.indexes.json export-rules.js .firebaserc firebase.json test_auth_check.json prod_auth_check.json
          echo "‚úÖ Successfully completed Firebase rules and indexes sync"

      - name: Cleanup S3 Artifacts
        if: always() && github.event.inputs.environment != 'only-sync-rules'
        run: |
          if [ -f ".aws-sam/build/packaged.yaml" ]; then
            # Extract S3 URI - find line with s3:// and extract the full URI
            S3_URI=$(grep "s3://" .aws-sam/build/packaged.yaml | grep -v "^#" | head -1 | grep -o 's3://[^[:space:]]*' | head -1)
            if [ ! -z "$S3_URI" ] && [[ "$S3_URI" == s3://* ]]; then
              echo "üßπ Cleaning up S3 artifact: $S3_URI"
              aws s3 rm "$S3_URI" || echo "‚ùå Failed to delete S3 artifact"
            fi
          fi
