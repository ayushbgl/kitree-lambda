name: Deploy Lambda Stack

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        type: choice
        options:
          - test
          - prod
          - both
          - only-sync-rules

permissions:
  contents: read
  id-token: write

env:
  DEPLOYMENT_BUCKET: kitree-backend
  FIREBASE_PROJECT_ID_TEST: kitree-test
  FIREBASE_PROJECT_ID_PROD: mirai-1111
  FIREBASE_TEST_DIR: firebase-test
  FIREBASE_PROD_DIR: firebase-prod
  LAMBDA_RESOURCE_NAME: JavaFunction

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main repository
        uses: actions/checkout@v4

      - name: Checkout secrets repository
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/kitree-secrets
          token: ${{ secrets.REPO_ACCESS_TOKEN }}
          path: secrets

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '22'

      - name: Setup Java
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'
        if: ${{ github.event.inputs.environment != 'only-sync-rules' }}

      - name: Install Google Cloud SDK
        if: ${{ github.event.inputs.environment == 'prod' || github.event.inputs.environment == 'both' || github.event.inputs.environment == 'only-sync-rules' }}
        run: |
          echo "ğŸ“¦ Installing Google Cloud SDK for debugging..."
          curl https://sdk.cloud.google.com | bash
          source ~/google-cloud-sdk/path.bash.inc
          echo "âœ… Google Cloud SDK installed"

      - name: Copy secret files
        if: ${{ github.event.inputs.environment != 'only-sync-rules' }}
        run: |
          mkdir -p src/main/resources
          cp secrets/kitree-lambda/secrets.json src/main/resources/
          cp secrets/kitree-lambda/serviceAccountKey.json src/main/resources/
          cp secrets/kitree-lambda/serviceAccountKeyTest.json src/main/resources/

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        if: ${{ github.event.inputs.environment != 'only-sync-rules' }}
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Install AWS SAM CLI
        if: ${{ github.event.inputs.environment != 'only-sync-rules' }}
        run: |
          pip install aws-sam-cli

      - name: Deploy Test Environment
        if: ${{ github.event.inputs.environment == 'test' || github.event.inputs.environment == 'both' }}
        run: |
          echo "ğŸš€ Deploying to TEST environment..."
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT_KEY_TEST }}' > firebase-test-key.json
          export GOOGLE_APPLICATION_CREDENTIALS=firebase-test-key.json
          
          echo "âœ… Verifying TEST credentials..."
          if [ -f "firebase-test-key.json" ]; then
            echo "âœ… Test service account file created successfully"
            echo "ğŸ“§ Test service account email: $(cat firebase-test-key.json | jq -r '.client_email')"
            echo "ğŸ“‹ Test project ID: $(cat firebase-test-key.json | jq -r '.project_id')"
          else
            echo "âŒ Failed to create test service account file"
            exit 1
          fi
          
          sam build
          sam package \
            --template-file .aws-sam/build/template.yaml \
            --output-template-file .aws-sam/build/packaged.yaml \
            --s3-bucket ${{ env.DEPLOYMENT_BUCKET }}
          
          sam deploy \
            --template-file .aws-sam/build/packaged.yaml \
            --stack-name java-lambda-test \
            --capabilities CAPABILITY_IAM \
            --parameter-overrides \
            Environment=test \
            FirebaseProject=${{ env.FIREBASE_PROJECT_ID_TEST }} \
            --no-fail-on-empty-changeset

      - name: Deploy Production Environment
        if: ${{ github.event.inputs.environment == 'prod' || github.event.inputs.environment == 'both' }}
        run: |
          echo "ğŸš€ Deploying to PRODUCTION environment..."
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT_KEY_PROD }}' > firebase-prod-key.json
          export GOOGLE_APPLICATION_CREDENTIALS=firebase-prod-key.json
          
          echo "âœ… Verifying PRODUCTION credentials..."
          if [ -f "firebase-prod-key.json" ]; then
            echo "âœ… Production service account file created successfully"
            echo "ğŸ“§ Production service account email: $(cat firebase-prod-key.json | jq -r '.client_email')"
            echo "ğŸ“‹ Production project ID: $(cat firebase-prod-key.json | jq -r '.project_id')"
          else
            echo "âŒ Failed to create production service account file"
            exit 1
          fi
          
          sam build
          sam package \
            --template-file .aws-sam/build/template.yaml \
            --output-template-file .aws-sam/build/packaged.yaml \
            --s3-bucket ${{ env.DEPLOYMENT_BUCKET }}
          
          sam deploy \
            --template-file .aws-sam/build/packaged.yaml \
            --stack-name java-lambda-prod \
            --capabilities CAPABILITY_IAM \
            --parameter-overrides \
            Environment=prod \
            FirebaseProject=${{ env.FIREBASE_PROJECT_ID_PROD }} \
            --no-fail-on-empty-changeset

      - name: Sync Firebase Rules and Indexes
        if: ${{ github.event.inputs.environment == 'prod' || github.event.inputs.environment == 'both' || github.event.inputs.environment == 'only-sync-rules' }}
        run: |
          echo "ğŸ”„ Starting Firebase Rules and Indexes sync..."
          echo "ğŸ“‹ Selected environment: ${{ github.event.inputs.environment }}"
          
          # Install Firebase CLI and Admin SDK
          echo "ğŸ“¦ Installing Firebase CLI and Admin SDK..."
          npm install -g firebase-tools
          npm install firebase-admin
          echo "âœ… Packages installed successfully"

          # Create service account files
          echo "ğŸ”‘ Creating service account files..."
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT_KEY_TEST }}' > firebase-test-key.json
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT_KEY_PROD }}' > firebase-prod-key.json
          
          # Verify both credential files
          echo "ğŸ” Verifying credential files..."
          if [ -f "firebase-test-key.json" ]; then
            echo "âœ… Test service account file created"
            echo "ğŸ“§ Test service account email: $(cat firebase-test-key.json | jq -r '.client_email')"
            echo "ğŸ“‹ Test project ID from key: $(cat firebase-test-key.json | jq -r '.project_id')"
            echo "ğŸ“‹ Expected test project ID: ${{ env.FIREBASE_PROJECT_ID_TEST }}"
          
            if jq empty firebase-test-key.json 2>/dev/null; then
              echo "âœ… Test service account JSON is valid"
            else
              echo "âŒ Test service account JSON is invalid"
              exit 1
            fi
          else
            echo "âŒ Failed to create test service account file"
            exit 1
          fi
          
          if [ -f "firebase-prod-key.json" ]; then
            echo "âœ… Production service account file created"
            echo "ğŸ“§ Production service account email: $(cat firebase-prod-key.json | jq -r '.client_email')"
            echo "ğŸ“‹ Production project ID from key: $(cat firebase-prod-key.json | jq -r '.project_id')"
            echo "ğŸ“‹ Expected production project ID: ${{ env.FIREBASE_PROJECT_ID_PROD }}"
          
            if jq empty firebase-prod-key.json 2>/dev/null; then
              echo "âœ… Production service account JSON is valid"
            else
              echo "âŒ Production service account JSON is invalid"
              exit 1
            fi
          else
            echo "âŒ Failed to create production service account file"
            exit 1
          fi

          # Create .firebaserc file for project aliases
          echo "âš™ï¸ Creating Firebase configuration..."
          cat > .firebaserc << 'EOF'
          {
            "projects": {
              "test": "${{ env.FIREBASE_PROJECT_ID_TEST }}",
              "prod": "${{ env.FIREBASE_PROJECT_ID_PROD }}"
            }
          }
          EOF

          # Create basic firebase.json configuration
          cat > firebase.json << 'EOF'
          {
            "firestore": {
              "rules": "firestore.rules",
              "indexes": "firestore.indexes.json"
            }
          }
          EOF
          echo "âœ… Firebase configuration files created"

          # Export from test project
          echo "ğŸ“¤ Exporting from TEST project (${{ env.FIREBASE_PROJECT_ID_TEST }})..."
          export GOOGLE_APPLICATION_CREDENTIALS=firebase-test-key.json
          
          # Test Firebase CLI authentication
          echo "ğŸ” Testing Firebase CLI authentication with test project..."
          firebase projects:list --json > test_auth_check.json || {
            echo "âŒ Failed to authenticate with Firebase CLI using test credentials"
            cat test_auth_check.json 2>/dev/null || echo "No output from Firebase CLI"
            exit 1
          }
          echo "âœ… Firebase CLI authentication successful for test project"
          
          firebase use test
          echo "âœ… Switched to test project"
          
          # Export indexes
          echo "ğŸ“‹ Exporting indexes from test project..."
          firebase firestore:indexes > firestore.indexes.json
          if [ -f "firestore.indexes.json" ]; then
            echo "âœ… Indexes exported successfully"
            echo "ğŸ“„ Indexes file size: $(wc -l < firestore.indexes.json) lines"
            echo "ğŸ“„ Indexes content preview:"
            head -n 10 firestore.indexes.json
          else
            echo "âŒ Failed to export indexes"
            exit 1
          fi

          # Export rules using Firebase Admin SDK with CORRECTED logic
          echo "ğŸ“‹ Exporting rules from test project using Admin SDK..."
          cat > export-rules.js << 'EOF'
          const admin = require('firebase-admin');
          const fs = require('fs');

          async function exportRules() {
            try {
              console.log('ğŸ” Initializing Firebase Admin SDK for test project...');
              const serviceAccount = require('./firebase-test-key.json');
              console.log('ğŸ“§ Service account email:', serviceAccount.client_email);
              console.log('ğŸ“‹ Service account project_id:', serviceAccount.project_id);
              console.log('ğŸ“‹ Environment FIREBASE_PROJECT_ID_TEST:', process.env.FIREBASE_PROJECT_ID_TEST);
          
              admin.initializeApp({
                credential: admin.credential.cert(serviceAccount),
                projectId: process.env.FIREBASE_PROJECT_ID_TEST
              });
              console.log('âœ… Firebase Admin SDK initialized successfully');

              console.log('ğŸ“‹ Getting security rules...');
              const securityRules = admin.securityRules();
          
              console.log('ğŸ” Attempting to list all rulesets...');
              const rulesetsResponse = await securityRules.listRulesetMetadata();
              console.log('ğŸ“Š Raw rulesets response type:', typeof rulesetsResponse);
          
              // FIXED: Access the rulesets array from the response object
              const rulesets = rulesetsResponse.rulesets || rulesetsResponse;
              console.log(`ğŸ“Š Found ${rulesets ? rulesets.length : 0} rulesets`);
          
              if (rulesets && Array.isArray(rulesets) && rulesets.length > 0) {
                console.log('ğŸ“¤ Getting latest ruleset...');
                const latestRuleset = rulesets[0];
                console.log('ğŸ“‹ Latest ruleset details:', JSON.stringify(latestRuleset, null, 2));
          
                const ruleset = await securityRules.getRuleset(latestRuleset.name);
                console.log('ğŸ“‹ Retrieved ruleset has source:', !!ruleset.source);
                console.log('ğŸ“‹ Source type:', typeof ruleset.source);
                console.log('ğŸ“‹ Source is array:', Array.isArray(ruleset.source));
          
                // CORRECTED: ruleset.source is directly the array of files
                if (ruleset.source && Array.isArray(ruleset.source)) {
                  console.log(`ğŸ“ Found ${ruleset.source.length} files in ruleset`);
                  console.log('ğŸ“ Files in ruleset:', ruleset.source.map(f => f.name));
          
                  const rulesFile = ruleset.source.find(file => file.name === 'firestore.rules');
                  if (rulesFile && rulesFile.content) {
                    fs.writeFileSync('firestore.rules', rulesFile.content);
                    console.log('âœ… Successfully exported rules from test project');
                    console.log('ğŸ“„ Rules file size:', rulesFile.content.length, 'characters');
                    console.log('ğŸ“„ Rules preview (first 10 lines):');
                    console.log(rulesFile.content.split('\n').slice(0, 10).join('\n'));
                    console.log('ğŸ“„ Rules preview (last 5 lines):');
                    console.log(rulesFile.content.split('\n').slice(-5).join('\n'));
                  } else {
                    console.log('âš ï¸ No rules content found in ruleset file');
                    console.log('ğŸ“‹ Rules file details:', rulesFile);
                    throw new Error('No rules content in file');
                  }
                } else {
                  console.log('âš ï¸ Source is not an array');
                  console.log('ğŸ“‹ Ruleset source structure:', ruleset.source);
                  throw new Error('Unexpected source structure');
                }
              } else {
                console.log('âš ï¸ No rulesets found or rulesets is not an array');
                if (rulesetsResponse) {
                  console.log('ğŸ“‹ Full response structure:', Object.keys(rulesetsResponse));
                }
                throw new Error('No rulesets found');
              }
            } catch (error) {
              console.error('âŒ Error in exportRules:', error.message);
              console.error('ğŸ“‹ Error code:', error.code);
              console.error('ğŸ“‹ Full error:', error);
          
              // Create a basic rules file as fallback
              console.log('âš ï¸ Creating fallback rules file due to error');
              fs.writeFileSync('firestore.rules', `rules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if false;\n    }\n  }\n}`);
              console.log('ğŸ“„ Fallback rules created');
          
              // Re-throw the error so we know something went wrong
              throw error;
            }
          }

          exportRules().catch(error => {
            console.error('ğŸ’¥ Final error in exportRules:', error);
            process.exit(1);
          });
          EOF

          export FIREBASE_PROJECT_ID_TEST='${{ env.FIREBASE_PROJECT_ID_TEST }}'
          node export-rules.js

          # Verify the exported rules
          if [ -f "firestore.rules" ]; then
            echo "ğŸ“„ Final exported rules file content:"
            cat firestore.rules
            echo ""
            echo "ğŸ“Š Rules file stats:"
            echo "  - Size: $(wc -c < firestore.rules) bytes"
            echo "  - Lines: $(wc -l < firestore.rules) lines"
            echo "  - Words: $(wc -w < firestore.rules) words"
          else
            echo "âŒ No rules file was created!"
            exit 1
          fi

          # Deploy to production project
          echo "ğŸ“¤ Deploying to PRODUCTION project (${{ env.FIREBASE_PROJECT_ID_PROD }})..."
          export GOOGLE_APPLICATION_CREDENTIALS=firebase-prod-key.json
          
          # Test Firebase CLI authentication for prod
          echo "ğŸ” Testing Firebase CLI authentication with production project..."
          firebase projects:list --json > prod_auth_check.json || {
            echo "âŒ Failed to authenticate with Firebase CLI using production credentials"
            cat prod_auth_check.json 2>/dev/null || echo "No output from Firebase CLI"
            exit 1
          }
          echo "âœ… Firebase CLI authentication successful for production"
          
          firebase use prod
          echo "âœ… Switched to production project"

          # Deploy rules to production with force flag to avoid confirmations
          if [ -f "firestore.rules" ]; then
            echo "ğŸ“‹ Deploying rules to production..."
            echo "ğŸ“„ Rules file content preview:"
            head -n 5 firestore.rules
            echo "ğŸš€ Starting Firebase rules deployment (force mode to avoid confirmations)..."
            firebase deploy --only firestore:rules --force --non-interactive
            if [ $? -eq 0 ]; then
              echo "âœ… Rules deployed to production successfully"
            else
              echo "âŒ Failed to deploy rules to production"
              exit 1
            fi
          else
            echo "âš ï¸ No rules file found to deploy"
          fi

          # Deploy indexes to production with force flag to avoid confirmations
          if [ -f "firestore.indexes.json" ]; then
            echo "ğŸ“‹ Deploying indexes to production..."
            echo "ğŸ“„ Indexes file content preview:"
            head -n 5 firestore.indexes.json
            echo "ğŸš€ Starting Firebase indexes deployment (force mode to avoid confirmations)..."
            firebase deploy --only firestore:indexes --force --non-interactive
            if [ $? -eq 0 ]; then
              echo "âœ… Indexes deployed to production successfully"
            else
              echo "âŒ Failed to deploy indexes to production"
              exit 1
            fi
          else
            echo "âš ï¸ No indexes file found to deploy"
          fi

          # Cleanup
          echo "ğŸ§¹ Cleaning up temporary files..."
          rm -f firebase-test-key.json firebase-prod-key.json firestore.rules firestore.indexes.json export-rules.js .firebaserc firebase.json test_auth_check.json prod_auth_check.json
          echo "âœ… Successfully completed Firebase rules and indexes sync"

      - name: Cleanup S3 Artifacts
        if: always() && github.event.inputs.environment != 'only-sync-rules'
        run: |
          if [ -f ".aws-sam/build/packaged.yaml" ]; then
            S3_URI=$(grep -A 1 "CodeUri:" .aws-sam/build/packaged.yaml | grep "s3://" | sed 's/^[[:space:]]*//')
            if [ ! -z "$S3_URI" ]; then
              echo "ğŸ§¹ Cleaning up S3 artifact: $S3_URI"
              aws s3 rm "$S3_URI" || echo "âŒ Failed to delete S3 artifact"
            fi
          fi
