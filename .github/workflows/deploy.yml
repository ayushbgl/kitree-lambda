name: Deploy Lambda Stack

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - test
          - prod
          - both
          - only-sync-rules
      skip_tests:
        description: 'Skip CI tests (unit + emulator)'
        type: boolean
        default: true

permissions:
  contents: read
  id-token: write

env:
  DEPLOYMENT_BUCKET: kitree-backend
  FIREBASE_PROJECT_ID_TEST: kitree-test
  FIREBASE_PROJECT_ID_PROD: mirai-1111
  FIREBASE_TEST_DIR: firebase-test
  FIREBASE_PROD_DIR: firebase-prod
  LAMBDA_RESOURCE_NAME: JavaFunction
  API_DOMAIN_TEST: api-test.kitree.co.in
  API_DOMAIN_PROD: api.kitree.co.in
  API_CERTIFICATE_ARN: arn:aws:acm:us-east-1:585768141144:certificate/33d1035e-b43b-4ba2-8bb4-342cb185139b

jobs:
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Job 1: CI â€” unit + integration + E2E tests against Firebase emulators
  # Skipped by default (skip_tests: true). Set skip_tests: false for prod runs.
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ci:
    if: inputs.skip_tests != true
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Set up JDK 21
        uses: actions/setup-java@v5
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Install Firebase CLI
        run: curl -sL https://firebase.tools | bash

      - name: Cache Firebase Emulators
        uses: actions/cache@v4
        with:
          path: ~/.cache/firebase/emulators
          key: firebase-emulators-${{ runner.os }}

      - name: Start Firebase Emulators
        run: |
          cat > .firebaserc << EOF
          {
            "projects": {
              "default": "kitree-emulator"
            }
          }
          EOF

          cat > firebase.json << EOF
          {
            "emulators": {
              "auth": {
                "host": "0.0.0.0",
                "port": 9099
              },
              "firestore": {
                "host": "0.0.0.0",
                "port": 8080
              }
            },
            "firestore": {
              "rules": "firestore.rules"
            }
          }
          EOF

          echo "rules_version = '2'; service cloud.firestore { match /databases/{database}/documents { match /{document=**} { allow read, write: if true; } } }" > firestore.rules

          firebase emulators:start --project kitree-emulator --only auth,firestore &

          wait_for_service() {
            local host=$1
            local port=$2
            local max_attempts=30
            local attempt=1
            echo "Waiting for service at $host:$port..."
            while [ $attempt -le $max_attempts ]; do
              if nc -z $host $port; then
                echo "âœ… $host:$port is ready"
                return 0
              fi
              echo "  attempt $attempt/$max_attempts..."
              sleep 2
              attempt=$((attempt + 1))
            done
            echo "âŒ $host:$port failed to start"
            return 1
          }

          wait_for_service localhost 8080 || exit 1
          wait_for_service localhost 9099 || exit 1

          echo "Verifying Auth emulator..."
          for i in {1..5}; do
            if curl -s -X POST http://localhost:9099/identitytoolkit/v3/relyingparty/signupNewUser \
              -H "Content-Type: application/json" \
              -d '{"email":"healthcheck@example.com","password":"password123"}' > /dev/null; then
              echo "âœ… Auth emulator responding"
              break
            fi
            [ $i -eq 5 ] && echo "âŒ Auth emulator not responding" && exit 1
            sleep 2
          done

          echo "Verifying Firestore emulator..."
          for i in {1..5}; do
            if curl -s "http://localhost:8080/emulator/v1/projects/kitree-emulator/databases/(default)/documents" > /dev/null; then
              echo "âœ… Firestore emulator responding"
              break
            fi
            [ $i -eq 5 ] && echo "âŒ Firestore emulator not responding" && exit 1
            sleep 2
          done

      - name: Run all tests
        env:
          FIRESTORE_EMULATOR_HOST: localhost:8080
          FIREBASE_AUTH_EMULATOR_HOST: localhost:9099
          FIREBASE_PROJECT_ID: kitree-emulator
          ENVIRONMENT: test
        run: ./gradlew test --info --console=plain

      - name: Test Results Summary
        if: always()
        run: |
          echo "## ðŸ§ª Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          TOTAL=0
          PASSED=0
          FAILED=0
          SKIPPED=0

          for f in build/test-results/test/*.xml; do
            [ -f "$f" ] || continue
            T=$(grep -o 'tests="[0-9]*"' "$f" | head -1 | grep -o '[0-9]*')
            F=$(grep -o 'failures="[0-9]*"' "$f" | head -1 | grep -o '[0-9]*')
            E=$(grep -o 'errors="[0-9]*"' "$f" | head -1 | grep -o '[0-9]*')
            S=$(grep -o 'skipped="[0-9]*"' "$f" | head -1 | grep -o '[0-9]*')
            T=${T:-0}; F=${F:-0}; E=${E:-0}; S=${S:-0}
            TOTAL=$((TOTAL + T))
            FAILED=$((FAILED + F + E))
            SKIPPED=$((SKIPPED + S))
          done
          PASSED=$((TOTAL - FAILED - SKIPPED))

          echo "| Metric | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Total | $TOTAL |" >> $GITHUB_STEP_SUMMARY
          echo "| âœ… Passed | $PASSED |" >> $GITHUB_STEP_SUMMARY
          echo "| â­ï¸ Skipped | $SKIPPED |" >> $GITHUB_STEP_SUMMARY
          echo "| âŒ Failed | $FAILED |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "$FAILED" -gt 0 ]; then
            echo "### âŒ $FAILED test(s) failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Class | Test |" >> $GITHUB_STEP_SUMMARY
            echo "|-------|------|" >> $GITHUB_STEP_SUMMARY
            for f in build/test-results/test/*.xml; do
              [ -f "$f" ] || continue
              CLASS=$(grep -o 'classname="[^"]*"' "$f" | head -1 | sed 's/classname="//;s/"//')
              # Find failed testcases
              grep '<testcase' "$f" | while IFS= read -r line; do
                TNAME=$(echo "$line" | grep -o 'name="[^"]*"' | head -1 | sed 's/name="//;s/"//')
                # Check if this testcase has a failure or error child element
                # In single-line XML, failure/error follows the testcase opening tag
                if echo "$line" | grep -q '<failure\|<error'; then
                  TCLASS=$(echo "$line" | grep -o 'classname="[^"]*"' | head -1 | sed 's/classname="//;s/"//')
                  echo "| $TCLASS | $TNAME |" >> $GITHUB_STEP_SUMMARY
                fi
              done
              # Also handle multi-line XML: look for testcases followed by failure/error
              awk '/<testcase/{tc=$0} /<failure|<error/{if(tc) print tc; tc=""}' "$f" | while IFS= read -r line; do
                TNAME=$(echo "$line" | grep -o 'name="[^"]*"' | head -1 | sed 's/name="//;s/"//')
                TCLASS=$(echo "$line" | grep -o 'classname="[^"]*"' | head -1 | sed 's/classname="//;s/"//')
                echo "| $TCLASS | $TNAME |" >> $GITHUB_STEP_SUMMARY
              done
            done
            echo "" >> $GITHUB_STEP_SUMMARY
          else
            echo "### âœ… All tests passed!" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload test reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-reports
          path: build/reports/tests/test/

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Job 2: Deploy
  # Runs if ci passed or was skipped (skip_tests: true)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  deploy:
    needs: [ci]
    if: always() && (needs.ci.result == 'success' || needs.ci.result == 'skipped')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main repository
        uses: actions/checkout@v5

      - name: Checkout secrets repository
        uses: actions/checkout@v5
        with:
          repository: ${{ github.repository_owner }}/kitree-secrets
          token: ${{ secrets.REPO_ACCESS_TOKEN }}
          path: secrets

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Setup Java
        if: inputs.environment != 'only-sync-rules'
        uses: actions/setup-java@v5
        with:
          distribution: 'temurin'
          java-version: '21'

      # (Optional) You probably do not need gcloud for Firebase CLI,
      # so consider deleting this step entirely.
      - name: Install Google Cloud SDK
        if: inputs.environment == 'prod' || inputs.environment == 'both' || inputs.environment == 'only-sync-rules'
        run: |
          echo "ðŸ“¦ Installing Google Cloud SDK for debugging..."
          curl https://sdk.cloud.google.com | bash
          source ~/google-cloud-sdk/path.bash.inc
          echo "âœ… Google Cloud SDK installed"

      - name: Copy secret files
        if: inputs.environment != 'only-sync-rules'
        run: |
          mkdir -p src/main/resources
          cp secrets/kitree-lambda/secrets.json src/main/resources/
          cp secrets/kitree-lambda/serviceAccountKey.json src/main/resources/
          cp secrets/kitree-lambda/serviceAccountKeyTest.json src/main/resources/

      - name: Configure AWS credentials
        if: inputs.environment != 'only-sync-rules'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Install AWS SAM CLI
        if: inputs.environment != 'only-sync-rules'
        run: pip install aws-sam-cli

      - name: Resolve deployment parameters
        if: inputs.environment != 'only-sync-rules'
        id: resolve-params
        run: |
          # Read ASTROLOGY_API_TOKEN from kitree-secrets
          ASTROLOGY_API_TOKEN=$(jq -r '.ASTROLOGY_API_TOKEN // empty' secrets/kitree-lambda/secrets.json)
          if [ -z "$ASTROLOGY_API_TOKEN" ]; then
            echo "âŒ ASTROLOGY_API_TOKEN not found in secrets/kitree-lambda/secrets.json"
            exit 1
          fi
          echo "âœ… ASTROLOGY_API_TOKEN loaded from kitree-secrets"
          # Mask the token so it doesn't appear in logs
          echo "::add-mask::$ASTROLOGY_API_TOKEN"
          echo "ASTROLOGY_API_TOKEN=$ASTROLOGY_API_TOKEN" >> $GITHUB_ENV

          # Dynamically fetch astrology lambda Function URL for each environment
          if [ "${{ inputs.environment }}" = "test" ] || [ "${{ inputs.environment }}" = "both" ]; then
            TEST_URL=$(aws lambda get-function-url-config \
              --function-name kitree-astrology-api-test \
              --query 'FunctionUrl' --output text 2>/dev/null || echo "")
            if [ -z "$TEST_URL" ]; then
              echo "âŒ Could not fetch Function URL for kitree-astrology-api-test. Is it deployed?"
              exit 1
            fi
            echo "âœ… Astrology test URL: $TEST_URL"
            echo "ASTROLOGY_LAMBDA_URL_TEST=$TEST_URL" >> $GITHUB_ENV
          fi

          if [ "${{ inputs.environment }}" = "prod" ] || [ "${{ inputs.environment }}" = "both" ]; then
            PROD_URL=$(aws lambda get-function-url-config \
              --function-name kitree-astrology-api-prod \
              --query 'FunctionUrl' --output text 2>/dev/null || echo "")
            if [ -z "$PROD_URL" ]; then
              echo "âŒ Could not fetch Function URL for kitree-astrology-api-prod. Is it deployed?"
              exit 1
            fi
            echo "âœ… Astrology prod URL: $PROD_URL"
            echo "ASTROLOGY_LAMBDA_URL_PROD=$PROD_URL" >> $GITHUB_ENV
          fi

      - name: Deploy Test Environment
        if: inputs.environment == 'test' || inputs.environment == 'both'
        run: |
          echo "ðŸš€ Deploying to TEST environment..."
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT_KEY_TEST }}' > firebase-test-key.json
          export GOOGLE_APPLICATION_CREDENTIALS=firebase-test-key.json

          echo "âœ… Verifying TEST credentials..."
          if [ -f "firebase-test-key.json" ]; then
            echo "âœ… Test service account file created successfully"
            echo "ðŸ“§ Test service account email: $(cat firebase-test-key.json | jq -r '.client_email')"
            echo "ðŸ“‹ Test project ID: $(cat firebase-test-key.json | jq -r '.project_id')"
          else
            echo "âŒ Failed to create test service account file"
            exit 1
          fi

          sam build
          sam package \
            --template-file .aws-sam/build/template.yaml \
            --output-template-file .aws-sam/build/packaged.yaml \
            --s3-bucket ${{ env.DEPLOYMENT_BUCKET }}

          sam deploy \
            --template-file .aws-sam/build/packaged.yaml \
            --stack-name java-lambda-test \
            --capabilities CAPABILITY_IAM \
            --parameter-overrides \
              Environment=test \
              FirebaseProject=${{ env.FIREBASE_PROJECT_ID_TEST }} \
              ApiDomainName=${{ env.API_DOMAIN_TEST }} \
              CertificateArn=${{ env.API_CERTIFICATE_ARN }} \
              AstrologyLambdaUrl=${ASTROLOGY_LAMBDA_URL_TEST} \
              AstrologyApiToken=${ASTROLOGY_API_TOKEN} \
            --no-fail-on-empty-changeset

          echo "ðŸ“¤ Fetching important TEST stack outputs..."
          TEST_OUTPUTS=$(sam list stack-outputs --stack-name java-lambda-test --output json)

          TEST_CF_DOMAIN=$(echo "$TEST_OUTPUTS" | jq -r '.[] | select(.OutputKey=="CloudFrontDomainName") | .OutputValue')
          TEST_CUSTOM_DOMAIN=$(echo "$TEST_OUTPUTS" | jq -r '.[] | select(.OutputKey=="ApiCustomDomainUrl") | .OutputValue')

          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ TEST ENVIRONMENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo "CloudFrontDomainName: $TEST_CF_DOMAIN"
          echo "ApiCustomDomainUrl : $TEST_CUSTOM_DOMAIN"
          echo "ðŸ‘‰ Add a CNAME/ALIAS in Netlify:"
          echo "   ${API_DOMAIN_TEST} â†’ $TEST_CF_DOMAIN"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

      - name: Deploy Production Environment
        if: inputs.environment == 'prod' || inputs.environment == 'both'
        run: |
          echo "ðŸš€ Deploying to PRODUCTION environment..."
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT_KEY_PROD }}' > firebase-prod-key.json
          export GOOGLE_APPLICATION_CREDENTIALS=firebase-prod-key.json

          echo "âœ… Verifying PRODUCTION credentials..."
          if [ -f "firebase-prod-key.json" ]; then
            echo "âœ… Production service account file created successfully"
            echo "ðŸ“§ Production service account email: $(cat firebase-prod-key.json | jq -r '.client_email')"
            echo "ðŸ“‹ Production project ID: $(cat firebase-prod-key.json | jq -r '.project_id')"
          else
            echo "âŒ Failed to create production service account file"
            exit 1
          fi

          sam build
          sam package \
            --template-file .aws-sam/build/template.yaml \
            --output-template-file .aws-sam/build/packaged.yaml \
            --s3-bucket ${{ env.DEPLOYMENT_BUCKET }}

          sam deploy \
            --template-file .aws-sam/build/packaged.yaml \
            --stack-name java-lambda-prod \
            --capabilities CAPABILITY_IAM \
            --parameter-overrides \
              Environment=prod \
              FirebaseProject=${{ env.FIREBASE_PROJECT_ID_PROD }} \
              ApiDomainName=${{ env.API_DOMAIN_PROD }} \
              CertificateArn=${{ env.API_CERTIFICATE_ARN }} \
              AstrologyLambdaUrl=${ASTROLOGY_LAMBDA_URL_PROD} \
              AstrologyApiToken=${ASTROLOGY_API_TOKEN} \
            --no-fail-on-empty-changeset

          echo "ðŸ“¤ Fetching important PROD stack outputs..."
          PROD_OUTPUTS=$(sam list stack-outputs --stack-name java-lambda-prod --output json)

          PROD_CF_DOMAIN=$(echo "$PROD_OUTPUTS" | jq -r '.[] | select(.OutputKey=="CloudFrontDomainName") | .OutputValue')
          PROD_CUSTOM_DOMAIN=$(echo "$PROD_OUTPUTS" | jq -r '.[] | select(.OutputKey=="ApiCustomDomainUrl") | .OutputValue')

          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ PRODUCTION ENVIRONMENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo "CloudFrontDomainName: $PROD_CF_DOMAIN"
          echo "ApiCustomDomainUrl : $PROD_CUSTOM_DOMAIN"
          echo "ðŸ‘‰ Add a CNAME/ALIAS in Netlify:"
          echo "   ${API_DOMAIN_PROD} â†’ $PROD_CF_DOMAIN"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

      - name: Deployment Summary
        if: always() && inputs.environment != 'only-sync-rules'
        run: |
          echo "## ðŸš€ Lambda Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ inputs.environment }}" = "test" ] || [ "${{ inputs.environment }}" = "both" ]; then
            echo "### TEST Environment" >> $GITHUB_STEP_SUMMARY
            TEST_OUTPUTS=$(aws cloudformation describe-stacks --stack-name java-lambda-test --query 'Stacks[0].Outputs' --output json 2>/dev/null || echo "[]")
            TEST_API_URL=$(echo "$TEST_OUTPUTS" | jq -r '.[] | select(.OutputKey=="ApiCustomDomainUrl") | .OutputValue' 2>/dev/null || echo "N/A")
            TEST_CF=$(echo "$TEST_OUTPUTS" | jq -r '.[] | select(.OutputKey=="CloudFrontDomainName") | .OutputValue' 2>/dev/null || echo "N/A")
            TEST_FN_URL=$(echo "$TEST_OUTPUTS" | jq -r '.[] | select(.OutputKey=="ApiEndpoint") | .OutputValue' 2>/dev/null || echo "N/A")
            echo "| Resource | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| ðŸŒ API URL | \`${TEST_API_URL}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| â˜ï¸ CloudFront | \`${TEST_CF}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| âš¡ Function URL | \`${TEST_FN_URL}\` |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ‘‰ CNAME: \`${{ env.API_DOMAIN_TEST }}\` â†’ \`${TEST_CF}\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          if [ "${{ inputs.environment }}" = "prod" ] || [ "${{ inputs.environment }}" = "both" ]; then
            echo "### PROD Environment" >> $GITHUB_STEP_SUMMARY
            PROD_OUTPUTS=$(aws cloudformation describe-stacks --stack-name java-lambda-prod --query 'Stacks[0].Outputs' --output json 2>/dev/null || echo "[]")
            PROD_API_URL=$(echo "$PROD_OUTPUTS" | jq -r '.[] | select(.OutputKey=="ApiCustomDomainUrl") | .OutputValue' 2>/dev/null || echo "N/A")
            PROD_CF=$(echo "$PROD_OUTPUTS" | jq -r '.[] | select(.OutputKey=="CloudFrontDomainName") | .OutputValue' 2>/dev/null || echo "N/A")
            PROD_FN_URL=$(echo "$PROD_OUTPUTS" | jq -r '.[] | select(.OutputKey=="ApiEndpoint") | .OutputValue' 2>/dev/null || echo "N/A")
            echo "| Resource | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| ðŸŒ API URL | \`${PROD_API_URL}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| â˜ï¸ CloudFront | \`${PROD_CF}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| âš¡ Function URL | \`${PROD_FN_URL}\` |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ‘‰ CNAME: \`${{ env.API_DOMAIN_PROD }}\` â†’ \`${PROD_CF}\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Sync Firebase Rules and Indexes
        if: inputs.environment == 'prod' || inputs.environment == 'both' || inputs.environment == 'only-sync-rules'
        run: |
          echo "ðŸ”„ Starting Firebase Rules and Indexes sync..."
          echo "ðŸ“‹ Selected environment: ${{ inputs.environment }}"

          npm install -g firebase-tools
          npm install firebase-admin
          echo "âœ… Packages installed successfully"

          echo "ðŸ”‘ Creating service account files..."
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT_KEY_TEST }}' > firebase-test-key.json
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT_KEY_PROD }}' > firebase-prod-key.json

          echo "ðŸ” Verifying credential files..."
          if [ -f "firebase-test-key.json" ]; then
            echo "âœ… Test service account file created"
            echo "ðŸ“§ Test service account email: $(cat firebase-test-key.json | jq -r '.client_email')"
            echo "ðŸ“‹ Test project ID from key: $(cat firebase-test-key.json | jq -r '.project_id')"
            echo "ðŸ“‹ Expected test project ID: ${{ env.FIREBASE_PROJECT_ID_TEST }}"

            if jq empty firebase-test-key.json 2>/dev/null; then
              echo "âœ… Test service account JSON is valid"
            else
              echo "âŒ Test service account JSON is invalid"
              exit 1
            fi
          else
            echo "âŒ Failed to create test service account file"
            exit 1
          fi

          if [ -f "firebase-prod-key.json" ]; then
            echo "âœ… Production service account file created"
            echo "ðŸ“§ Production service account email: $(cat firebase-prod-key.json | jq -r '.client_email')"
            echo "ðŸ“‹ Production project ID from key: $(cat firebase-prod-key.json | jq -r '.project_id')"
            echo "ðŸ“‹ Expected production project ID: ${{ env.FIREBASE_PROJECT_ID_PROD }}"

            if jq empty firebase-prod-key.json 2>/dev/null; then
              echo "âœ… Production service account JSON is valid"
            else
              echo "âŒ Production service account JSON is invalid"
              exit 1
            fi
          else
            echo "âŒ Failed to create production service account file"
            exit 1
          fi

          cat > .firebaserc << 'EOF'
          {
            "projects": {
              "test": "${{ env.FIREBASE_PROJECT_ID_TEST }}",
              "prod": "${{ env.FIREBASE_PROJECT_ID_PROD }}"
            }
          }
          EOF

          cat > firebase.json << 'EOF'
          {
            "firestore": {
              "rules": "firestore.rules",
              "indexes": "firestore.indexes.json"
            }
          }
          EOF
          echo "âœ… Firebase configuration files created"

          echo "ðŸ“¤ Exporting from TEST project (${{ env.FIREBASE_PROJECT_ID_TEST }})..."
          export GOOGLE_APPLICATION_CREDENTIALS=firebase-test-key.json

          echo "ðŸ” Testing Firebase CLI authentication with test project..."
          firebase projects:list --json > test_auth_check.json || {
            echo "âŒ Failed to authenticate with Firebase CLI using test credentials"
            cat test_auth_check.json 2>/dev/null || echo "No output from Firebase CLI"
            exit 1
          }
          echo "âœ… Firebase CLI authentication successful for test project"

          firebase use test
          echo "âœ… Switched to test project"

          # Export indexes
          echo "ðŸ“‹ Exporting indexes from test project..."
          firebase firestore:indexes > firestore.indexes.json
          if [ -f "firestore.indexes.json" ]; then
            echo "âœ… Indexes exported successfully"
            echo "ðŸ“„ Indexes file size: $(wc -l < firestore.indexes.json) lines"
            echo "ðŸ“„ Indexes content preview:"
            head -n 10 firestore.indexes.json
          else
            echo "âŒ Failed to export indexes"
            exit 1
          fi

          # Export rules using Firebase Admin SDK with CORRECTED logic
          echo "ðŸ“‹ Exporting rules from test project using Admin SDK..."
          cat > export-rules.js << 'EOF'
          const admin = require('firebase-admin');
          const fs = require('fs');

          async function exportRules() {
            try {
              console.log('ðŸ” Initializing Firebase Admin SDK for test project...');
              const serviceAccount = require('./firebase-test-key.json');
              console.log('ðŸ“§ Service account email:', serviceAccount.client_email);
              console.log('ðŸ“‹ Service account project_id:', serviceAccount.project_id);
              console.log('ðŸ“‹ Environment FIREBASE_PROJECT_ID_TEST:', process.env.FIREBASE_PROJECT_ID_TEST);

              admin.initializeApp({
                credential: admin.credential.cert(serviceAccount),
                projectId: process.env.FIREBASE_PROJECT_ID_TEST
              });
              console.log('âœ… Firebase Admin SDK initialized successfully');

              console.log('ðŸ“‹ Getting security rules...');
              const securityRules = admin.securityRules();

              console.log('ðŸ” Attempting to list all rulesets...');
              const rulesetsResponse = await securityRules.listRulesetMetadata();
              console.log('ðŸ“Š Raw rulesets response type:', typeof rulesetsResponse);

              // FIXED: Access the rulesets array from the response object
              const rulesets = rulesetsResponse.rulesets || rulesetsResponse;
              console.log(`ðŸ“Š Found ${rulesets ? rulesets.length : 0} rulesets`);

              if (rulesets && Array.isArray(rulesets) && rulesets.length > 0) {
                console.log('ðŸ“¤ Getting latest ruleset...');
                const latestRuleset = rulesets[0];
                console.log('ðŸ“‹ Latest ruleset details:', JSON.stringify(latestRuleset, null, 2));

                const ruleset = await securityRules.getRuleset(latestRuleset.name);
                console.log('ðŸ“‹ Retrieved ruleset has source:', !!ruleset.source);
                console.log('ðŸ“‹ Source type:', typeof ruleset.source);
                console.log('ðŸ“‹ Source is array:', Array.isArray(ruleset.source));

                // CORRECTED: ruleset.source is directly the array of files
                if (ruleset.source && Array.isArray(ruleset.source)) {
                  console.log(`ðŸ“ Found ${ruleset.source.length} files in ruleset`);
                  console.log('ðŸ“ Files in ruleset:', ruleset.source.map(f => f.name));

                  const rulesFile = ruleset.source.find(file => file.name === 'firestore.rules');
                  if (rulesFile && rulesFile.content) {
                    fs.writeFileSync('firestore.rules', rulesFile.content);
                    console.log('âœ… Successfully exported rules from test project');
                    console.log('ðŸ“„ Rules file size:', rulesFile.content.length, 'characters');
                    console.log('ðŸ“„ Rules preview (first 10 lines):');
                    console.log(rulesFile.content.split('\n').slice(0, 10).join('\n'));
                    console.log('ðŸ“„ Rules preview (last 5 lines):');
                    console.log(rulesFile.content.split('\n').slice(-5).join('\n'));
                  } else {
                    console.log('âš ï¸ No rules content found in ruleset file');
                    console.log('ðŸ“‹ Rules file details:', rulesFile);
                    throw new Error('No rules content in file');
                  }
                } else {
                  console.log('âš ï¸ Source is not an array');
                  console.log('ðŸ“‹ Ruleset source structure:', ruleset.source);
                  throw new Error('Unexpected source structure');
                }
              } else {
                console.log('âš ï¸ No rulesets found or rulesets is not an array');
                if (rulesetsResponse) {
                  console.log('ðŸ“‹ Full response structure:', Object.keys(rulesetsResponse));
                }
                throw new Error('No rulesets found');
              }
            } catch (error) {
              console.error('âŒ Error in exportRules:', error.message);
              console.error('ðŸ“‹ Error code:', error.code);
              console.error('ðŸ“‹ Full error:', error);

              // Create a basic rules file as fallback
              console.log('âš ï¸ Creating fallback rules file due to error');
              fs.writeFileSync('firestore.rules', `rules_version = '2';\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    match /{document=**} {\n      allow read, write: if false;\n    }\n  }\n}`);
              console.log('ðŸ“„ Fallback rules created');

              // Re-throw the error so we know something went wrong
              throw error;
            }
          }

          exportRules().catch(error => {
            console.error('ðŸ’¥ Final error in exportRules:', error);
            process.exit(1);
          });
          EOF

          export FIREBASE_PROJECT_ID_TEST='${{ env.FIREBASE_PROJECT_ID_TEST }}'
          node export-rules.js

          # Verify the exported rules
          if [ -f "firestore.rules" ]; then
            echo "ðŸ“„ Final exported rules file content:"
            cat firestore.rules
            echo ""
            echo "ðŸ“Š Rules file stats:"
            echo "  - Size: $(wc -c < firestore.rules) bytes"
            echo "  - Lines: $(wc -l < firestore.rules) lines"
            echo "  - Words: $(wc -w < firestore.rules) words"
          else
            echo "âŒ No rules file was created!"
            exit 1
          fi

          echo "ðŸ“¤ Deploying to PRODUCTION project (${{ env.FIREBASE_PROJECT_ID_PROD }})..."
          export GOOGLE_APPLICATION_CREDENTIALS=firebase-prod-key.json

          echo "ðŸ” Testing Firebase CLI authentication with production project..."
          firebase projects:list --json > prod_auth_check.json || {
            echo "âŒ Failed to authenticate with Firebase CLI using production credentials"
            cat prod_auth_check.json 2>/dev/null || echo "No output from Firebase CLI"
            exit 1
          }
          echo "âœ… Firebase CLI authentication successful for production"

          firebase use prod
          echo "âœ… Switched to production project"

          if [ -f "firestore.rules" ]; then
            echo "ðŸ“‹ Deploying rules to production..."
            echo "ðŸ“„ Rules file content preview:"
            head -n 5 firestore.rules
            echo "ðŸš€ Starting Firebase rules deployment (force mode to avoid confirmations)..."
            firebase deploy --only firestore:rules --force --non-interactive
            if [ $? -eq 0 ]; then
              echo "âœ… Rules deployed to production successfully"
            else
              echo "âŒ Failed to deploy rules to production"
              exit 1
            fi
          else
            echo "âš ï¸ No rules file found to deploy"
          fi

          if [ -f "firestore.indexes.json" ]; then
            echo "ðŸ“‹ Deploying indexes to production..."
            echo "ðŸ“„ Indexes file content preview:"
            head -n 5 firestore.indexes.json
            echo "ðŸš€ Starting Firebase indexes deployment (force mode to avoid confirmations)..."
            firebase deploy --only firestore:indexes --force --non-interactive
            if [ $? -eq 0 ]; then
              echo "âœ… Indexes deployed to production successfully"
            else
              echo "âŒ Failed to deploy indexes to production"
              exit 1
            fi
          else
            echo "âš ï¸ No indexes file found to deploy"
          fi

          echo "ðŸ§¹ Cleaning up temporary files..."
          rm -f firebase-test-key.json firebase-prod-key.json firestore.rules firestore.indexes.json export-rules.js .firebaserc firebase.json test_auth_check.json prod_auth_check.json
          echo "âœ… Successfully completed Firebase rules and indexes sync"

      - name: Cleanup S3 Artifacts
        if: always() && inputs.environment != 'only-sync-rules'
        run: |
          if [ -f ".aws-sam/build/packaged.yaml" ]; then
            S3_URI=$(grep "s3://" .aws-sam/build/packaged.yaml | grep -v "^#" | head -1 | grep -o 's3://[^[:space:]]*' | head -1)
            if [ ! -z "$S3_URI" ] && [[ "$S3_URI" == s3://* ]]; then
              echo "ðŸ§¹ Cleaning up S3 artifact: $S3_URI"
              aws s3 rm "$S3_URI" || echo "âŒ Failed to delete S3 artifact"
            fi
          fi

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Job 3: Verify â€” cold start health check against the deployed API
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  verify:
    needs: [deploy]
    if: needs.deploy.result == 'success' && inputs.environment != 'only-sync-rules'
    runs-on: ubuntu-latest
    steps:
      - name: Health check â€” TEST
        if: inputs.environment == 'test' || inputs.environment == 'both'
        run: |
          echo "â±ï¸ Cold start check â€” https://${API_DOMAIN_TEST}"
          RESULT=$(curl -o response_test.json -s \
            -w "%{http_code} %{time_total}" \
            -X GET "https://${API_DOMAIN_TEST}/health" \
            --max-time 30)
          HTTP_CODE=$(echo $RESULT | awk '{print $1}')
          COLD_START=$(echo $RESULT | awk '{print $2}')
          echo "HTTP status : $HTTP_CODE"
          echo "Cold start  : ${COLD_START}s"
          echo "Response    : $(cat response_test.json)"
          if [ "$HTTP_CODE" != "200" ]; then
            echo "âŒ TEST health check failed"
            exit 1
          fi
          echo "âœ… TEST health check passed"
          echo "$COLD_START" > cold_start_test.txt
          echo "ðŸŽ‰ Cold start completed in ${COLD_START}s"
          if (( $(echo "$COLD_START < 5" | bc -l) )); then
              echo "âš¡ Excellent cold start performance!"
          elif (( $(echo "$COLD_START < 10" | bc -l) )); then
              echo "ðŸ‘ Good cold start performance"
          else
              echo "âš ï¸ Cold start is slow (${COLD_START}s) â€” consider optimization"
          fi

      - name: Health check â€” PROD
        if: inputs.environment == 'prod' || inputs.environment == 'both'
        run: |
          echo "â±ï¸ Cold start check â€” https://${API_DOMAIN_PROD}"
          RESULT=$(curl -o response_prod.json -s \
            -w "%{http_code} %{time_total}" \
            -X GET "https://${API_DOMAIN_PROD}/health" \
            --max-time 30)
          HTTP_CODE=$(echo $RESULT | awk '{print $1}')
          COLD_START=$(echo $RESULT | awk '{print $2}')
          echo "HTTP status : $HTTP_CODE"
          echo "Cold start  : ${COLD_START}s"
          echo "Response    : $(cat response_prod.json)"
          if [ "$HTTP_CODE" != "200" ]; then
            echo "âŒ PROD health check failed"
            exit 1
          fi
          echo "âœ… PROD health check passed"
          echo "$COLD_START" > cold_start_prod.txt
          echo "ðŸŽ‰ Cold start completed in ${COLD_START}s"
          if (( $(echo "$COLD_START < 5" | bc -l) )); then
              echo "âš¡ Excellent cold start performance!"
          elif (( $(echo "$COLD_START < 10" | bc -l) )); then
              echo "ðŸ‘ Good cold start performance"
          else
              echo "âš ï¸ Cold start is slow (${COLD_START}s) â€” consider optimization"
          fi

      - name: Verification Summary
        if: always()
        run: |
          echo "## ðŸ” Post-Deploy Verification" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ inputs.environment }}" = "test" ] || [ "${{ inputs.environment }}" = "both" ]; then
            echo "### TEST: https://${API_DOMAIN_TEST}" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`json" >> $GITHUB_STEP_SUMMARY
            cat response_test.json >> $GITHUB_STEP_SUMMARY 2>/dev/null || echo "(no response captured)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            if [ -f cold_start_test.txt ]; then
              TEST_CS=$(cat cold_start_test.txt)
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "ðŸŽ‰ **Cold start completed in ${TEST_CS}s**" >> $GITHUB_STEP_SUMMARY
              if (( $(echo "$TEST_CS < 5" | bc -l) )); then
                echo "âš¡ Excellent cold start performance!" >> $GITHUB_STEP_SUMMARY
              elif (( $(echo "$TEST_CS < 10" | bc -l) )); then
                echo "ðŸ‘ Good cold start performance" >> $GITHUB_STEP_SUMMARY
              else
                echo "âš ï¸ Cold start is slow (${TEST_CS}s) â€” consider optimization" >> $GITHUB_STEP_SUMMARY
              fi
              echo "" >> $GITHUB_STEP_SUMMARY
            fi
          fi
          if [ "${{ inputs.environment }}" = "prod" ] || [ "${{ inputs.environment }}" = "both" ]; then
            echo "### PROD: https://${API_DOMAIN_PROD}" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`json" >> $GITHUB_STEP_SUMMARY
            cat response_prod.json >> $GITHUB_STEP_SUMMARY 2>/dev/null || echo "(no response captured)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            if [ -f cold_start_prod.txt ]; then
              PROD_CS=$(cat cold_start_prod.txt)
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "ðŸŽ‰ **Cold start completed in ${PROD_CS}s**" >> $GITHUB_STEP_SUMMARY
              if (( $(echo "$PROD_CS < 5" | bc -l) )); then
                echo "âš¡ Excellent cold start performance!" >> $GITHUB_STEP_SUMMARY
              elif (( $(echo "$PROD_CS < 10" | bc -l) )); then
                echo "ðŸ‘ Good cold start performance" >> $GITHUB_STEP_SUMMARY
              else
                echo "âš ï¸ Cold start is slow (${PROD_CS}s) â€” consider optimization" >> $GITHUB_STEP_SUMMARY
              fi
              echo "" >> $GITHUB_STEP_SUMMARY
            fi
          fi
